<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motivation</title>
    <style>
        body {
            background-color: #000;
            color: #fff;
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            perspective: 1000px; /* Essential for 3D flip */
        }

        .container {
            max-width: 85%;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .quote-wrapper {
            /* Wrapper ensures 3D context stays stable */
            transform-style: preserve-3d;
        }

        .quote {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            line-height: 1.3;
            color: #fff;
            
            /* MASSIVE GLOW (4 Layers) */
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 30px rgba(255, 255, 255, 0.6),
                0 0 80px rgba(255, 255, 255, 0.4),
                0 0 120px rgba(255, 255, 255, 0.2);

            opacity: 1;
            transform: rotateX(0deg);
            transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1), 
                        opacity 0.6s ease;
            backface-visibility: hidden; /* Hides the text when flipped backwards */
        }

        /* Animation Classes */
        .flip-out {
            transform: rotateX(90deg);
            opacity: 0;
        }
        
        .flip-in {
            animation: flipIn 0.8s cubic-bezier(0.4, 0.0, 0.2, 1) forwards;
        }

        @keyframes flipIn {
            from { transform: rotateX(-90deg); opacity: 0; }
            to   { transform: rotateX(0deg); opacity: 1; }
        }

        .author {
            color: #888;
            font-size: 1.5rem;
            margin-top: 30px;
            text-align: right;
            font-style: italic;
            letter-spacing: 1px;
            opacity: 1;
            transition: opacity 0.5s;
        }
        
        .author.fade-out { opacity: 0; }

        /* Hollow Button Controls */
        .controls {
            margin-top: 80px;
            display: flex;
            gap: 40px;
            opacity: 0; 
            transition: opacity 1s;
        }

        .btn {
            background: transparent;
            border: 2px solid #555; 
            color: #555;
            width: 60px;
            height: 60px;
            font-size: 1.8rem;
            cursor: pointer;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            outline: none;
        }

        .btn:hover {
            border-color: #aaa;
            color: #aaa;
        }

        .btn.active {
            border-color: #fff;
            color: #fff;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        /* Debug info */
        .debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #222;
            font-size: 10px;
            font-family: monospace;
            pointer-events: none;
        }

        @media (max-width: 600px) {
            .quote { font-size: 2rem; text-shadow: 0 0 15px rgba(255, 255, 255, 0.8), 0 0 40px rgba(255, 255, 255, 0.4); }
            .author { font-size: 1.1rem; margin-top: 20px; }
            .controls { margin-top: 50px; gap: 30px; }
            .btn { width: 50px; height: 50px; font-size: 1.5rem; }
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="quote-wrapper">
            <div id="quote-text" class="quote"></div>
        </div>
        <div id="author-text" class="author"></div>
    </div>

    <div class="controls" id="controls">
        <button class="btn" id="btn-bad" onclick="rateQuote('bad')" aria-label="Dislike">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path></svg>
        </button>
        <button class="btn" id="btn-good" onclick="rateQuote('good')" aria-label="Like">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
        </button>
    </div>

    <div id="debug" class="debug-info"></div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            jsonPath: './quotes.json',
            hoursToWait: 3,
            explorationChance: 0.20,
            weights: {
                base: 50,
                likedBonus: 15,
                topicMatchBonus: 100,
                dislikedPenalty: 0.1
            }
        };

        const TOPIC_KEYWORDS = {
            "success": ["success", "great", "win", "victory", "work", "job", "accomplish"],
            "resilience": ["failure", "impossible", "fall", "continue", "courage", "fatal", "halfway", "stand"],
            "patience": ["clock", "time", "wait", "future", "now", "moment", "patience"],
            "action": ["do", "done", "going", "way", "path", "start", "begin"],
            "mindset": ["believe", "think", "thought", "mind", "dream"]
        };

        // --- STATE ---
        let allQuotes = [];
        let currentQuoteId = null;
        let isAnimating = false;

        // --- HELPERS ---
        function analyzeTopics(text) {
            let foundTopics = new Set();
            const lowerText = text.toLowerCase();
            for (const [topic, words] of Object.entries(TOPIC_KEYWORDS)) {
                for (const word of words) {
                    if (lowerText.includes(word)) foundTopics.add(topic);
                }
            }
            if (foundTopics.size === 0) foundTopics.add("general");
            return Array.from(foundTopics);
        }

        function getRatings() {
            const stored = localStorage.getItem('motivation_ratings');
            return stored ? JSON.parse(stored) : {};
        }

        function saveRating(id, rating) {
            const ratings = getRatings();
            ratings[id] = rating;
            localStorage.setItem('motivation_ratings', JSON.stringify(ratings));
        }

        function getCookie(name) {
            const v = document.cookie.match('(^|;) ?' + name + '=([^;]*)(;|$)');
            return v ? v[2] : null;
        }

        function setCookie(name, value, hours) {
            const d = new Date();
            d.setTime(d.getTime() + (hours * 60 * 60 * 1000));
            document.cookie = `${name}=${value};path=/;expires=${d.toGMTString()}`;
        }

        function deleteCookie(name) {
            document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
        }

        // --- ALGORITHM ---
        function selectSmartQuote(quotes) {
            const ratings = getRatings();
            let topicProfile = {};
            
            quotes.forEach(q => {
                if (ratings[q.id] === 'good' && q.topics) {
                    q.topics.forEach(t => topicProfile[t] = (topicProfile[t] || 0) + 1);
                }
            });

            if (Math.random() < CONFIG.explorationChance) {
                return quotes[Math.floor(Math.random() * quotes.length)];
            }

            let weightedPool = [];
            quotes.forEach(q => {
                let weight = CONFIG.weights.base;
                const userRating = ratings[q.id];

                if (userRating === 'good') weight += CONFIG.weights.likedBonus; 
                if (userRating === 'bad') weight *= CONFIG.weights.dislikedPenalty; 

                if (q.topics) {
                    q.topics.forEach(t => {
                        if (topicProfile[t] > 0) weight += CONFIG.weights.topicMatchBonus * topicProfile[t];
                    });
                }
                weightedPool.push({ quote: q, weight: weight });
            });

            const totalWeight = weightedPool.reduce((sum, item) => sum + item.weight, 0);
            let randomValue = Math.random() * totalWeight;
            
            for (const item of weightedPool) {
                randomValue -= item.weight;
                if (randomValue <= 0) return item.quote;
            }
            return quotes[0];
        }

        // --- CORE LOGIC ---
        async function loadData() {
            try {
                const response = await fetch(CONFIG.jsonPath);
                let data = await response.json();
                allQuotes = data.map(q => ({ ...q, topics: analyzeTopics(q.quote) }));
                checkTimeAndRender(true); // 'true' means first load
            } catch (err) {
                console.error(err);
                document.getElementById('quote-text').innerText = "Load Error";
            }
        }

        function checkTimeAndRender(isFirstLoad = false) {
            const savedId = getCookie('motivation_id');
            const savedTime = getCookie('motivation_time');
            const now = Date.now();
            const timeLimit = CONFIG.hoursToWait * 3600 * 1000;

            let shouldUpdate = true;
            let selectedQuote = null;

            // 1. Check if we have a valid saved quote
            if (savedId && savedTime) {
                const diff = now - parseInt(savedTime);
                if (diff < timeLimit) {
                    shouldUpdate = false;
                    // If it's first load, we must fetch the object. 
                    // If it's a background check, and we shouldn't update, we do nothing.
                    if (isFirstLoad) {
                        selectedQuote = allQuotes.find(q => q.id == savedId);
                    }
                }
            }

            // 2. If time expired or no cookie, pick new one
            if (shouldUpdate) {
                // Determine if we need to animate (only if not first load)
                const animate = !isFirstLoad; 
                
                selectedQuote = selectSmartQuote(allQuotes);
                
                // Save immediately
                setCookie('motivation_id', selectedQuote.id, CONFIG.hoursToWait);
                setCookie('motivation_time', now.toString(), CONFIG.hoursToWait);
                
                if (animate) {
                    performFlipAnimation(selectedQuote);
                } else {
                    renderDirectly(selectedQuote);
                }
            } else if (isFirstLoad && selectedQuote) {
                renderDirectly(selectedQuote);
            }
        }

        // --- ANIMATION & RENDERING ---
        
        function renderDirectly(quote) {
            currentQuoteId = quote.id;
            document.getElementById('quote-text').innerText = quote.quote;
            document.getElementById('author-text').innerText = `— ${quote.author}`;
            document.getElementById('debug').innerText = `ID: ${quote.id}`;
            document.getElementById('controls').style.opacity = 1;
            updateButtonStyles();
        }

        function performFlipAnimation(quote) {
            if (isAnimating) return;
            isAnimating = true;

            const qText = document.getElementById('quote-text');
            const aText = document.getElementById('author-text');

            // 1. Flip Out
            qText.classList.add('flip-out');
            aText.classList.add('fade-out');

            setTimeout(() => {
                // 2. Update Content (while invisible)
                currentQuoteId = quote.id;
                qText.innerText = quote.quote;
                aText.innerText = `— ${quote.author}`;
                updateButtonStyles();
                document.getElementById('debug').innerText = `ID: ${quote.id}`;

                // 3. Prepare Flip In
                qText.classList.remove('flip-out');
                qText.classList.add('flip-in');
                aText.classList.remove('fade-out');

                // 4. Cleanup after animation ends
                setTimeout(() => {
                    qText.classList.remove('flip-in');
                    isAnimating = false;
                }, 800); // match CSS animation duration

            }, 600); // match CSS transition duration
        }

        function updateButtonStyles() {
            const ratings = getRatings();
            const rating = ratings[currentQuoteId];
            const btnGood = document.getElementById('btn-good');
            const btnBad = document.getElementById('btn-bad');

            btnGood.className = 'btn';
            btnBad.className = 'btn';

            if (rating === 'good') btnGood.classList.add('active');
            if (rating === 'bad') btnBad.classList.add('active');
        }

        // --- USER ACTIONS ---
        window.rateQuote = function(type) {
            if (!currentQuoteId || isAnimating) return;
            const ratings = getRatings();
            
            if (ratings[currentQuoteId] === type) {
                delete ratings[currentQuoteId];
            } else {
                saveRating(currentQuoteId, type);
            }
            
            localStorage.setItem('motivation_ratings', JSON.stringify(ratings));
            updateButtonStyles();

            // If Dislike, force a flip immediately
            if (type === 'bad') {
               deleteCookie('motivation_id');
               deleteCookie('motivation_time');
               // Trigger the check logic, which will see no cookie and animate a new one
               checkTimeAndRender(false);
            }
        };

        // --- TIMERS & EVENTS ---
        
        // 1. Initial Load
        loadData();

        // 2. Check every 5 seconds (Live Update)
        setInterval(() => {
            if (!isAnimating && allQuotes.length > 0) {
                checkTimeAndRender(false);
            }
        }, 5000);

        // 3. Check immediately when user switches back to tab
        document.addEventListener("visibilitychange", () => {
            if (document.visibilityState === 'visible' && !isAnimating && allQuotes.length > 0) {
                checkTimeAndRender(false);
            }
        });

    </script>
</body>
</html>
